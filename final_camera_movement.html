<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - pointerlock controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0);

			}

			#instructions {

				width: 100%;
				height: 100%;
				padding-top: 2rem;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}

		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/PointerLockControls.js"></script>

		<div id="blocker">

			<div id="instructions">
				(W, A, S, D = Move, Shift = Run, MOUSE = Look around)
			</div>

		</div>

		<script>

			var camera, scene, renderer, controls;


			var controlsEnabled = true;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var shift = false;
			var space = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var color = new THREE.Color();
			var box = new THREE.Box3();
			var min;
			var max;

			function createTerrain(scene) {
				createAshphalt(scene);
				createMountains(scene);
				createRocks(scene);
			}

			function createRocks(scene) {
				const rockGeometry = new THREE.PlaneGeometry(100, 100, 500, 500);

				let rockDisplacementMap = new THREE.TextureLoader()
				.load("heightmap/rock-displacement.png")

				let rockTexture = new THREE.TextureLoader()
				.load("terrain/rock-texture.jpg")

				const rockMaterial = new THREE.MeshStandardMaterial({
					color: 'grey',
					map: rockTexture,
					displacementMap: rockDisplacementMap,
					displacementScale: 1
				})

				const rockMesh = new THREE.Mesh(rockGeometry, rockMaterial);
				rockMesh.rotation.x = -Math.PI / 2;
				rockMesh.position.x = 500;
				scene.add(rockMesh);
			}

			function createMountains(scene) {
				const mountainGeometry = new THREE.PlaneGeometry(900,900, 500, 500);
				const largerMountainGeometry = new THREE.PlaneGeometry(1200, 900, 500, 500)

				let mountainDisplacementMap = new THREE.TextureLoader()
				.load("heightmap/heightmap.png");

				let mountainTexture = new THREE.TextureLoader()
				.load("terrain/rock-texture.jpg");

				const mountainMaterial = new THREE.MeshStandardMaterial({
					color: 'grey',
					map: mountainTexture,
					displacementMap: mountainDisplacementMap,
					displacementScale: 70,
				})

				scene.add(createMountain(mountainGeometry, mountainMaterial, 1000, 0));
				scene.add(createMountain(mountainGeometry, mountainMaterial, -1000, 0));
				scene.add(createMountain(mountainGeometry, mountainMaterial, 0, 1000));
				scene.add(createMountain(mountainGeometry, mountainMaterial, 0, -1000));
				scene.add(createMountain(largerMountainGeometry, mountainMaterial, 1000, -1000));
				scene.add(createMountain(largerMountainGeometry, mountainMaterial, 1150, -800));
				scene.add(createMountain(largerMountainGeometry, mountainMaterial, -1000, 1000));
				scene.add(createMountain(largerMountainGeometry, mountainMaterial, -1150, 800));
			}

			function createMountain(mountainGeometry, mountainMaterial, x, z) {
				const mountainMesh = new THREE.Mesh(mountainGeometry, mountainMaterial);
				mountainMesh.rotation.x = -Math.PI / 2;
				mountainMesh.position.x = x;
				mountainMesh.position.z = z;
				return mountainMesh;
			}

			function createAshphalt(scene) {
				const cityGeometry = new THREE.PlaneGeometry(100, 100, 500, 500);

				let asphaltDisplacementMap = new THREE.TextureLoader()
				.load("heightmap/asphalt-displacement.png");

				let asphaltTexture = new THREE.TextureLoader()
				.load("terrain/asphalt-texture.jpg");

				const asphaltMaterial = new THREE.MeshStandardMaterial({
					color: 'grey',
					map: asphaltTexture,
					displacementMap: asphaltDisplacementMap,
					displacementScale: 1,
				})

				for (var i = 0; i < 5; ++i) {
					for (var j = 0; j < 5; ++j) {
						const ashphaltMeshZ = createAshphaltMesh(cityGeometry, asphaltMaterial);
						ashphaltMeshZ.position.z = j * 100;
						ashphaltMeshZ.position.x = i * 100;
						scene.add(ashphaltMeshZ);

						const ashphaltMeshZNeg = createAshphaltMesh(cityGeometry, asphaltMaterial);
						ashphaltMeshZNeg.position.z = j * -100;
						ashphaltMeshZNeg.position.x = i * 100;
						scene.add(ashphaltMeshZNeg);

						const ashphaltMeshZNegX = createAshphaltMesh(cityGeometry, asphaltMaterial);
						ashphaltMeshZNegX.position.z = j * 100;
						ashphaltMeshZNegX.position.x = i * -100;
						scene.add(ashphaltMeshZNegX);

						const ashphaltMeshZNegXNeg = createAshphaltMesh(cityGeometry, asphaltMaterial);
						ashphaltMeshZNegXNeg.position.z = j * -100;
						ashphaltMeshZNegXNeg.position.x = i * -100;
						scene.add(ashphaltMeshZNegXNeg);
					}
					const ashphaltMeshX = createAshphaltMesh(cityGeometry, asphaltMaterial);
					ashphaltMeshX.position.x = i * 100;
					scene.add(ashphaltMeshX);

					const ashphaltMeshXNeg = createAshphaltMesh(cityGeometry, asphaltMaterial);
					ashphaltMeshXNeg.position.x = i * -100;
					scene.add(ashphaltMeshXNeg);
				}
			}

			function createAshphaltMesh(cityGeometry, asphaltMaterial) {
				ashphaltMesh = new THREE.Mesh(cityGeometry, asphaltMaterial);
				ashphaltMesh.rotation.x = -Math.PI / 2;
				return ashphaltMesh;
			}

			function generateBuildings(scene) {
				
			}


			function init() {

				var ratio = window.innerWidth/window.innerHeight;
				camera = new THREE.PerspectiveCamera(45,ratio,0.00001,1000);
				var Pos = new THREE.Vector3(0,0,0);
				camera.position.set(Pos.x,Pos.y,Pos.z);
				var Dir = new THREE.Vector3(0,0,1);
				camera.lookAt(Dir.x,Dir.y,Dir.z);

				scene = new THREE.Scene();

				createTerrain(scene);
				 
				let sun = new THREE.DirectionalLight(0xFFFFFF, 1);
				sun.position.set(2,10,1);
				sun.target.position.set(0,0,0);

				scene.add(sun);
				scene.add(sun.target);

				// var geometry = new THREE.PlaneBufferGeometry( 300, 300 );
				// var material = new THREE.MeshStandardMaterial({ color: 0xff1100 });

				// var mesh = new THREE.Mesh( geometry, material );

				// scene.add( mesh );

				controls = new THREE.PointerLockControls( camera );

        		controls.enabled = true;
				scene.add( controls.getObject() );

				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
              				break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 16: //shift
							shift = true;
							break;
						
						case 32: //space
							space = true;
							break;
					}

				};

				var onKeyUp = function ( event ) {

					switch( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

						case 16: //shift
							shift = false;
							break;
							
						case 32: //space
						space = false;
						break;

					}
				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				// var material_floor = new THREE.MeshBasicMaterial();
				// material_floor.shininess=100;
				// material_floor.wireframe = true;
				// material_floor.color=  new THREE.Color(0.8,0.9,0.3);
				// var geometry_floor = new THREE.BoxGeometry(100,2,100,32,1,32);
				// var meshFloor= new THREE.Mesh( geometry_floor, material_floor );
				// scene.add( meshFloor );

				// meshFloor.geometry.computeBoundingBox();
				// box.copy( meshFloor.geometry.boundingBox );
				// min = box.min;
				// max = box.max;
				// console.log(min.x);
				// console.log(max);
				// console.log(controls.getObject().position.x);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			init();

			function animate() {

				requestAnimationFrame( animate );

				if ( controlsEnabled == true ) {

				 	var time = performance.now();
					var delta =  ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 15.0 * delta;
					velocity.z -= velocity.z * 15.0 * delta;
					velocity.y -= velocity.y * 15.0 * delta;

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveLeft ) - Number( moveRight );
					direction.normalize();

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 450.0 * delta;
					if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z -= direction.z * 500.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 450.0 * delta;
					if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x -= direction.x * 500.0 * delta;
					if ( space ) {
						velocity.y += 1 * 500.0 * delta;
					}


					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateZ( velocity.z * delta );
					controls.getObject().translateY( velocity.y * delta );

					if (controls.getObject().position.y > 5 ) {
						velocity.y -= 1 * 500.0 * delta;
					}

					prevTime = time;

				}

				// //Collision detection for plane edges
				// if (controls.getObject().position.x < min.x) {
				// 	if ( moveForward || moveBackward ) velocity.z = 10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = 10;
				// 	if ( moveLeft || moveRight ) velocity.x = 10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = 10;
				// }

				// if (controls.getObject().position.x > max.x) {
				// 	if ( moveForward || moveBackward ) velocity.z = -10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = -10;
				// 	if ( moveLeft || moveRight ) velocity.x = -10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = -10;
				// }

				// if (controls.getObject().position.z < min.z) {
				// 	if ( moveForward || moveBackward ) velocity.z = 10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = 10;
				// 	if ( moveLeft || moveRight ) velocity.x = 10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = 10;
				// }

				// if (controls.getObject().position.z > max.z) {
				// 	if ( moveForward || moveBackward ) velocity.z = -10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = -10;
				// 	if ( moveLeft || moveRight ) velocity.x = -10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = -10;
				// }

				renderer.render( scene, camera );
			}
			animate();

		</script>
	</body>
</html>