<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - pointerlock controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0);

			}

			#instructions {

				width: 100%;
				height: 100%;
				padding-top: 2rem;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}

		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/PointerLockControls.js"></script>
		<script src="./terrain-generation.js"></script>

		<div id="mapCanvas" style="position: absolute; left:100px; top:100px; width:320px; height:240px;"></div>
		<div id="blocker">

			<div id="instructions">
				(W, A, S, D = Move, Shift = Run, MOUSE = Look around)
			</div>

		</div>

		<script>

			var camera, scene, renderer, controls;
			var mapCamera, mapWidth = 240, mapHeight = 160;


			var controlsEnabled = true;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var shift = false;
			var space = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var color = new THREE.Color();
			var box = new THREE.Box3();
			var min;
			var max;

			function init() {
				scene = new THREE.Scene();

				var ratio = window.innerWidth/window.innerHeight;
				camera = new THREE.PerspectiveCamera(45,ratio,0.00001,1000);
				var Pos = new THREE.Vector3(0,0,0);
				camera.position.set(Pos.x,Pos.y,Pos.z);
				var Dir = new THREE.Vector3(0,0,1);
				camera.lookAt(Dir.x,Dir.y,Dir.z);
				scene.add(camera);

				// orthographic cameras
				mapCamera = new THREE.OrthographicCamera(
				window.innerWidth / -20,		// Left
				window.innerWidth / 20,		// Right
				window.innerHeight / 20,		// Top
				window.innerHeight / -20,	// Bottom
				-5000,            			// Near 
				10000 );           			// Far 
				mapCamera.up = new THREE.Vector3(0,0,-1);
				mapCamera.lookAt( new THREE.Vector3(0,-1,0) );
				scene.add(mapCamera);

				createTerrain(scene);
				 
				let sun = new THREE.DirectionalLight(0xFFFFFF, 1);
				sun.position.set(2,10,1);
				sun.target.position.set(0,0,0);

				scene.add(sun);
				scene.add(sun.target);

				// var geometry = new THREE.PlaneBufferGeometry( 300, 300 );
				// var material = new THREE.MeshStandardMaterial({ color: 0xff1100 });

				// var mesh = new THREE.Mesh( geometry, material );

				// scene.add( mesh );

				controls = new THREE.PointerLockControls( camera );

        		controls.enabled = true;
				scene.add( controls.getObject() );

				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
              				break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 16: //shift
							shift = true;
							break;
						
						case 32: //space
							space = true;
							break;
					}

				};

				var onKeyUp = function ( event ) {

					switch( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

						case 16: //shift
							shift = false;
							break;
							
						case 32: //space
						space = false;
						break;

					}
				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				// var material_cube = new THREE.MeshBasicMaterial();
				// material_cube.color=  new THREE.Color(5,1,1);
				// var geometry_cube = new THREE.BoxGeometry(5,5,5);
   				// var cube_mesh = new THREE.Mesh(geometry_cube,material_cube);
    			// cube_mesh.position.x=10;
				// cube_mesh.position.y=3.5;
    			// scene.add(cube_mesh);

				// var material_floor = new THREE.MeshBasicMaterial();
				// material_floor.shininess=100;
				// material_floor.wireframe = true;
				// material_floor.color=  new THREE.Color(0.8,0.9,0.3);
				// var geometry_floor = new THREE.BoxGeometry(100,2,100,32,1,32);
				// var meshFloor= new THREE.Mesh( geometry_floor, material_floor );
				// scene.add( meshFloor );

				// meshFloor.geometry.computeBoundingBox();
				// box.copy( meshFloor.geometry.boundingBox );
				// min = box.min;
				// max = box.max;
				// console.log(min.x);
				// console.log(max);
				// console.log(controls.getObject().position.x);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			init();

			function animate() {

				requestAnimationFrame( animate );
				render();

				if ( controlsEnabled == true ) {

				 	var time = performance.now();
					var delta =  ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 15.0 * delta;
					velocity.z -= velocity.z * 15.0 * delta;
					velocity.y -= velocity.y * 15.0 * delta;

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveLeft ) - Number( moveRight );
					direction.normalize();

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 450.0 * delta;
					if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z -= direction.z * 500.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 450.0 * delta;
					if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x -= direction.x * 500.0 * delta;
					if ( space ) {
						if ( controls.getObject().position.y < 7) {
							velocity.y += 1 * 500.0 * delta;
						}
					}


					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateZ( velocity.z * delta );
					controls.getObject().translateY( velocity.y * delta );

					if (controls.getObject().position.y > 5 ) {
						velocity.y -= 1 * 500.0 * delta;
					}

					prevTime = time;

				}

				//Collision detection for plane edges
				// if (controls.getObject().position.x < -900) {
				// 	if ( moveForward || moveBackward ) velocity.z = 10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = 10;
				// 	if ( moveLeft || moveRight ) velocity.x = 10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = 10;
				// }

				// if (controls.getObject().position.x > 900) {
				// 	if ( moveForward || moveBackward ) velocity.z = -10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = -10;
				// 	if ( moveLeft || moveRight ) velocity.x = -10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = -10;
				// }

				// if (controls.getObject().position.z < -900) {
				// 	if ( moveForward || moveBackward ) velocity.z = 10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = 10;
				// 	if ( moveLeft || moveRight ) velocity.x = 10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = 10;
				// }

				// if (controls.getObject().position.z > 900) {
				// 	if ( moveForward || moveBackward ) velocity.z = -10;
				// 	if ( (moveForward && shift) || (moveBackward && shift) ) velocity.z = -10;
				// 	if ( moveLeft || moveRight ) velocity.x = -10;
				// 	if ( (moveLeft && shift) || (moveRight && shift) ) velocity.x = -10;
				// }

				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 1 );
				renderer.autoClear = false;
				
			}

function render() 
{
	var w = window.innerWidth, h = window.innerHeight;

	// setViewport parameters:
	//  lower_left_x, lower_left_y, viewport_width, viewport_height
	renderer.setViewport( 0, 0, w, h );
	renderer.clear();
	
	// full display
	// renderer.setViewport( 0, 0, SCREEN_WIDTH - 2, 0.5 * SCREEN_HEIGHT - 2 );
	renderer.render( scene, camera );
	
	// minimap (overhead orthogonal camera)
	//  lower_left_x, lower_left_y, viewport_width, viewport_height
	renderer.setViewport( 10, h - mapHeight - 10, mapWidth, mapHeight );
	renderer.render( scene, mapCamera );
}
			animate();

		</script>
	</body>
</html>